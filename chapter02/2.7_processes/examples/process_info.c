/**\n * 进程信息获取示例\n * 演示如何获取进程的基本信息\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <errno.h>\n#include <string.h>\n\nvoid print_process_info(const char *label) {\n    printf(\"=== %s ===\\n\", label);\n    printf(\"进程ID (PID): %d\\n\", getpid());\n    printf(\"父进程ID (PPID): %d\\n\", getppid());\n    printf(\"进程组ID (PGID): %d\\n\", getpgrp());\n    printf(\"用户ID (UID): %d\\n\", getuid());\n    printf(\"有效用户ID (EUID): %d\\n\", geteuid());\n    printf(\"组ID (GID): %d\\n\", getgid());\n    printf(\"有效组ID (EGID): %d\\n\", getegid());\n    printf(\"\\n\");\n}\n\nint main(void) {\n    pid_t pid;\n    int status;\n\n    print_process_info(\"父进程信息\");\n\n    printf(\"创建子进程...\\n\\n\");\n    \n    pid = fork();\n    \n    if (pid == -1) {\n        fprintf(stderr, \"fork() 失败: %s\\n\", strerror(errno));\n        exit(EXIT_FAILURE);\n    }\n    \n    if (pid == 0) {\n        // 子进程\n        print_process_info(\"子进程信息\");\n        \n        printf(\"子进程睡眠2秒...\\n\");\n        sleep(2);\n        \n        printf(\"子进程即将退出\\n\");\n        exit(42);  // 使用特定的退出码\n    } else {\n        // 父进程\n        printf(\"父进程创建了子进程，PID: %d\\n\\n\", pid);\n        \n        printf(\"父进程等待子进程结束...\\n\");\n        \n        // 等待子进程结束\n        pid_t waited_pid = wait(&status);\n        \n        if (waited_pid == -1) {\n            fprintf(stderr, \"wait() 失败: %s\\n\", strerror(errno));\n            exit(EXIT_FAILURE);\n        }\n        \n        printf(\"\\n子进程 %d 已结束\\n\", waited_pid);\n        \n        // 分析子进程退出状态\n        if (WIFEXITED(status)) {\n            printf(\"子进程正常退出，退出码: %d\\n\", WEXITSTATUS(status));\n        } else if (WIFSIGNALED(status)) {\n            printf(\"子进程被信号终止，信号: %d\\n\", WTERMSIG(status));\n        } else {\n            printf(\"子进程异常结束\\n\");\n        }\n        \n        print_process_info(\"父进程最终信息\");\n    }\n    \n    return EXIT_SUCCESS;\n}