/**\n * 用户和组信息获取示例\n * 演示如何获取和显示用户、组相关信息\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n\nvoid print_user_info(uid_t uid) {\n    struct passwd *pw = getpwuid(uid);\n    \n    if (pw == NULL) {\n        fprintf(stderr, \"无法获取UID %d的用户信息: %s\\n\", \n                uid, strerror(errno));\n        return;\n    }\n    \n    printf(\"用户信息 (UID: %d):\\n\", uid);\n    printf(\"  用户名: %s\\n\", pw->pw_name);\n    printf(\"  密码字段: %s\\n\", pw->pw_passwd);\n    printf(\"  用户ID: %d\\n\", pw->pw_uid);\n    printf(\"  组ID: %d\\n\", pw->pw_gid);\n    printf(\"  真实姓名: %s\\n\", pw->pw_gecos);\n    printf(\"  主目录: %s\\n\", pw->pw_dir);\n    printf(\"  登录Shell: %s\\n\", pw->pw_shell);\n    printf(\"\\n\");\n}\n\nvoid print_group_info(gid_t gid) {\n    struct group *gr = getgrgid(gid);\n    \n    if (gr == NULL) {\n        fprintf(stderr, \"无法获取GID %d的组信息: %s\\n\", \n                gid, strerror(errno));\n        return;\n    }\n    \n    printf(\"组信息 (GID: %d):\\n\", gid);\n    printf(\"  组名: %s\\n\", gr->gr_name);\n    printf(\"  密码字段: %s\\n\", gr->gr_passwd);\n    printf(\"  组ID: %d\\n\", gr->gr_gid);\n    printf(\"  组成员: \");\n    \n    if (gr->gr_mem[0] == NULL) {\n        printf(\"(无)\\n\");\n    } else {\n        for (int i = 0; gr->gr_mem[i] != NULL; i++) {\n            printf(\"%s%s\", (i > 0) ? \", \" : \"\", gr->gr_mem[i]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n\nvoid print_supplementary_groups(void) {\n    int ngroups = getgroups(0, NULL);\n    if (ngroups == -1) {\n        perror(\"getgroups\");\n        return;\n    }\n    \n    gid_t *groups = malloc(ngroups * sizeof(gid_t));\n    if (groups == NULL) {\n        perror(\"malloc\");\n        return;\n    }\n    \n    if (getgroups(ngroups, groups) == -1) {\n        perror(\"getgroups\");\n        free(groups);\n        return;\n    }\n    \n    printf(\"附加组列表:\\n\");\n    for (int i = 0; i < ngroups; i++) {\n        struct group *gr = getgrgid(groups[i]);\n        printf(\"  GID %d\", groups[i]);\n        if (gr != NULL) {\n            printf(\" (%s)\", gr->gr_name);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    \n    free(groups);\n}\n\nint main(void) {\n    uid_t real_uid = getuid();\n    uid_t effective_uid = geteuid();\n    gid_t real_gid = getgid();\n    gid_t effective_gid = getegid();\n    \n    printf(\"=== 当前进程的用户和组信息 ===\\n\\n\");\n    \n    printf(\"ID信息:\\n\");\n    printf(\"  实际用户ID (UID): %d\\n\", real_uid);\n    printf(\"  有效用户ID (EUID): %d\\n\", effective_uid);\n    printf(\"  实际组ID (GID): %d\\n\", real_gid);\n    printf(\"  有效组ID (EGID): %d\\n\", effective_gid);\n    printf(\"\\n\");\n    \n    // 显示实际用户信息\n    print_user_info(real_uid);\n    \n    // 如果有效用户ID不同，也显示有效用户信息\n    if (effective_uid != real_uid) {\n        printf(\"=== 有效用户信息 ===\\n\");\n        print_user_info(effective_uid);\n    }\n    \n    // 显示实际组信息\n    print_group_info(real_gid);\n    \n    // 如果有效组ID不同，也显示有效组信息\n    if (effective_gid != real_gid) {\n        printf(\"=== 有效组信息 ===\\n\");\n        print_group_info(effective_gid);\n    }\n    \n    // 显示附加组\n    print_supplementary_groups();\n    \n    // 测试权限检查\n    printf(\"=== 权限测试 ===\\n\");\n    \n    const char *test_file = \"/etc/passwd\";\n    printf(\"测试文件: %s\\n\", test_file);\n    \n    if (access(test_file, F_OK) == 0) {\n        printf(\"  文件存在: 是\\n\");\n    } else {\n        printf(\"  文件存在: 否\\n\");\n    }\n    \n    if (access(test_file, R_OK) == 0) {\n        printf(\"  可读: 是\\n\");\n    } else {\n        printf(\"  可读: 否\\n\");\n    }\n    \n    if (access(test_file, W_OK) == 0) {\n        printf(\"  可写: 是\\n\");\n    } else {\n        printf(\"  可写: 否\\n\");\n    }\n    \n    if (access(test_file, X_OK) == 0) {\n        printf(\"  可执行: 是\\n\");\n    } else {\n        printf(\"  可执行: 否\\n\");\n    }\n    \n    return EXIT_SUCCESS;\n}